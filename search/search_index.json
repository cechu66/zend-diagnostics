{
    "docs": [
        {
            "location": "/",
            "text": "Installation\n\n\nUsing Composer\n\n\n$ composer require zendframework/zenddiagnostics",
            "title": "Home"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#using-composer",
            "text": "$ composer require zendframework/zenddiagnostics",
            "title": "Using Composer"
        },
        {
            "location": "/usage/",
            "text": "Introduction and Usage\n\n\nzendframework/zenddiagnostics provides diagnostic tests for real-world PHP\napplications.\n\n\nIt currently ships with the following diagnostic checks:\n\n\n\n\nApcFragmentation\n - check if APC memory fragmentation is below given threshold,\n\n\nApcMemory\n - check available APC memory,\n\n\nCallback\n - call a user-defined diagnostic function,\n\n\nClassExists\n - make sure class exists in current environment,\n\n\nCouchDBCheck\n - check if connection is possible,\n\n\nCpuPerformance\n - check server CPU performance is above baseline,\n\n\nDirReadable\n - make sure given path is readable,\n\n\nDirWritable\n - make sure given path is writable,\n\n\nDiskFree\n - check there's enough free space on given path,\n\n\nDiskUsage\n - check if the disk usage is below warning/critical percent thresholds,\n\n\nDoctrineMigration\n - make sure all migrations are applied.\n\n\nExtensionLoaded\n - make sure extension is loaded,\n\n\nGuzzleHttpService\n - check if given http host is responding using Guzzle,\n\n\nHttpService\n - check if given http host is responding,\n\n\nMemcache\n - check if memcache extension is loaded and given server is reachable,\n\n\nMongo\n - check if connection to MongoDb is possible,\n\n\nOpCacheMemory\n - check if the OpCache memory usage is below warning/critical thresholds,\n\n\nPDOCheck\n - check if connection is possible,\n\n\nPhpVersion\n - make sure that PHP version matches constraint,\n\n\nPhpFlag\n - make sure that given PHP flag (feature) is turned on or off.\n\n\nProcessRunning\n - check if a process with given name or ID is currently running,\n\n\nRabbitMQ\n - Validate that a RabbitMQ service is running,\n\n\nRedis\n - Validate that a Redis service is running,\n\n\nSecurityAdvisory\n - check installed composer dependencies against SensioLabs SA database,\n\n\nStreamWrapperExists\n - make sure given stream wrapper is available.\n\n\n\n\nIt also provides the following file validation checks:\n\n\n\n\nIniFile\n - check if given INI file is available and valid,\n\n\nJsonFile\n - check if given JSON file is available and valid,\n\n\nXmlFile\n - check if given XML file is available and valid,\n\n\nYamlFile\n - check if given YAML file is available and valid\n\n\n\n\nPerforming diagnostics with Zend Framework 2\n\n\n\n\nInstall the \nZFTool module\n.\n\n\nEnable diagnostic tests in \nyour application config.php\n.\n\n\nIn your console type \nphp public/index.php diag\n to run diagnostics.\n\n\n\n\nNote: this does not work with Zend Framework 3; use the \nplain PHP\ndiagnostics\n instructions below when using that\nframework version.\n\n\nUsing diagnostics with Symfony 2\n\n\n\n\nInstall the \nLiipMonitorBundle\n.\n\n\nEnable diagnostic tests in \nyour application configuration\n.\n\n\nIn your console type \n./app/console monitor:health\n to run diagnostics.\n\n\n\n\nUsing diagnostics with PSR-7 middleware\n\n\nInstall the \nrstgroup/diagnostics-middleware\n.\n\n\nUsing diagnostics in plain PHP\n\n\n\n\nCreate an instance of \nZendDiagnostics\\Runner\n.\n\n\nAdd tests using \nRunner::addTest()\n.\n\n\nOptionally add a reporter to display progress using \nRunner::addReporter()\n.\n\n\nRun diagnostics \nRunner::run()\n.\n\n\n\n\nFor example:\n\n\n<?php\n// run_diagnostics.php\n\nuse ZendDiagnostics\\Check;\nuse ZendDiagnostics\\Runner\\Runner;\nuse ZendDiagnostics\\Runner\\Reporter\\BasicConsole;\n\ninclude 'vendor/autoload.php';\n\n// Create Runner instance\n$runner = new Runner();\n\n// Add checks\n$runner->addCheck(new Check\\DirWritable('/tmp'));\n$runner->addCheck(new Check\\DiskFree(100000000, '/tmp'));\n\n// Add console reporter\n$runner->addReporter(new BasicConsole(80, true));\n\n// Run all checks\n$results = $runner->run();\n\n// Emit an appropriate exit code\n$status = ($results->getFailureCount() + $results->getWarningCount()) > 0 ? 1 : 0;\nexit($status);\n\n\n\nYou can now run the file in your console (command line):\n\n\n$ php run_diagnostics.php\nStarting diagnostics:\n\n..\n\nOK (2 diagnostic tests)\n\n\n\nUsing a result collection\n\n\nThe diagnostics runner will always return a\n\nZendDiagnostics\\Result\\Collection\n,\neven when no reporter is attached. This collection contains results for all\ntests and failure counters.\n\n\nAs an example:\n\n\n<?php\nuse ZendDiagnostics\\Check;\nuse ZendDiagnostics\\Result;\nuse ZendDiagnostics\\Runner\\Runner;\n\n$runner = new Runner();\n$checkSpace = new Check\\DiskFree(100000000, '/tmp');\n$checkTemp  = new Check\\DirWritable('/tmp');\n$runner->addCheck($checkSpace);\n$runner->addCheck($checkTemp);\n\n// Run all checks\n$results = $runner->run();\n\necho \"Number of successful tests: \" . $results->getSuccessCount() . \"\\n\";\necho \"Number of failed tests:     \" . $results->getFailureCount() . \"\\n\";\n\nif ($results[$checkSpace] instanceof Result\\FailureInterface) {\n    echo \"Oooops! We're running out of space on temp.\\n\";\n}\n\nif ($results[$checkTemp] instanceof Result\\FailureInterface) {\n    echo \"It seems that /tmp is not writable - this is a serious problem!\\n\";\n}",
            "title": "Introduction and Usage"
        },
        {
            "location": "/usage/#introduction-and-usage",
            "text": "zendframework/zenddiagnostics provides diagnostic tests for real-world PHP\napplications.  It currently ships with the following diagnostic checks:   ApcFragmentation  - check if APC memory fragmentation is below given threshold,  ApcMemory  - check available APC memory,  Callback  - call a user-defined diagnostic function,  ClassExists  - make sure class exists in current environment,  CouchDBCheck  - check if connection is possible,  CpuPerformance  - check server CPU performance is above baseline,  DirReadable  - make sure given path is readable,  DirWritable  - make sure given path is writable,  DiskFree  - check there's enough free space on given path,  DiskUsage  - check if the disk usage is below warning/critical percent thresholds,  DoctrineMigration  - make sure all migrations are applied.  ExtensionLoaded  - make sure extension is loaded,  GuzzleHttpService  - check if given http host is responding using Guzzle,  HttpService  - check if given http host is responding,  Memcache  - check if memcache extension is loaded and given server is reachable,  Mongo  - check if connection to MongoDb is possible,  OpCacheMemory  - check if the OpCache memory usage is below warning/critical thresholds,  PDOCheck  - check if connection is possible,  PhpVersion  - make sure that PHP version matches constraint,  PhpFlag  - make sure that given PHP flag (feature) is turned on or off.  ProcessRunning  - check if a process with given name or ID is currently running,  RabbitMQ  - Validate that a RabbitMQ service is running,  Redis  - Validate that a Redis service is running,  SecurityAdvisory  - check installed composer dependencies against SensioLabs SA database,  StreamWrapperExists  - make sure given stream wrapper is available.   It also provides the following file validation checks:   IniFile  - check if given INI file is available and valid,  JsonFile  - check if given JSON file is available and valid,  XmlFile  - check if given XML file is available and valid,  YamlFile  - check if given YAML file is available and valid",
            "title": "Introduction and Usage"
        },
        {
            "location": "/usage/#performing-diagnostics-with-zend-framework-2",
            "text": "Install the  ZFTool module .  Enable diagnostic tests in  your application config.php .  In your console type  php public/index.php diag  to run diagnostics.   Note: this does not work with Zend Framework 3; use the  plain PHP\ndiagnostics  instructions below when using that\nframework version.",
            "title": "Performing diagnostics with Zend Framework 2"
        },
        {
            "location": "/usage/#using-diagnostics-with-symfony-2",
            "text": "Install the  LiipMonitorBundle .  Enable diagnostic tests in  your application configuration .  In your console type  ./app/console monitor:health  to run diagnostics.",
            "title": "Using diagnostics with Symfony 2"
        },
        {
            "location": "/usage/#using-diagnostics-with-psr-7-middleware",
            "text": "Install the  rstgroup/diagnostics-middleware .",
            "title": "Using diagnostics with PSR-7 middleware"
        },
        {
            "location": "/usage/#using-diagnostics-in-plain-php",
            "text": "Create an instance of  ZendDiagnostics\\Runner .  Add tests using  Runner::addTest() .  Optionally add a reporter to display progress using  Runner::addReporter() .  Run diagnostics  Runner::run() .   For example:  <?php\n// run_diagnostics.php\n\nuse ZendDiagnostics\\Check;\nuse ZendDiagnostics\\Runner\\Runner;\nuse ZendDiagnostics\\Runner\\Reporter\\BasicConsole;\n\ninclude 'vendor/autoload.php';\n\n// Create Runner instance\n$runner = new Runner();\n\n// Add checks\n$runner->addCheck(new Check\\DirWritable('/tmp'));\n$runner->addCheck(new Check\\DiskFree(100000000, '/tmp'));\n\n// Add console reporter\n$runner->addReporter(new BasicConsole(80, true));\n\n// Run all checks\n$results = $runner->run();\n\n// Emit an appropriate exit code\n$status = ($results->getFailureCount() + $results->getWarningCount()) > 0 ? 1 : 0;\nexit($status);  You can now run the file in your console (command line):  $ php run_diagnostics.php\nStarting diagnostics:\n\n..\n\nOK (2 diagnostic tests)",
            "title": "Using diagnostics in plain PHP"
        },
        {
            "location": "/usage/#using-a-result-collection",
            "text": "The diagnostics runner will always return a ZendDiagnostics\\Result\\Collection ,\neven when no reporter is attached. This collection contains results for all\ntests and failure counters.  As an example:  <?php\nuse ZendDiagnostics\\Check;\nuse ZendDiagnostics\\Result;\nuse ZendDiagnostics\\Runner\\Runner;\n\n$runner = new Runner();\n$checkSpace = new Check\\DiskFree(100000000, '/tmp');\n$checkTemp  = new Check\\DirWritable('/tmp');\n$runner->addCheck($checkSpace);\n$runner->addCheck($checkTemp);\n\n// Run all checks\n$results = $runner->run();\n\necho \"Number of successful tests: \" . $results->getSuccessCount() . \"\\n\";\necho \"Number of failed tests:     \" . $results->getFailureCount() . \"\\n\";\n\nif ($results[$checkSpace] instanceof Result\\FailureInterface) {\n    echo \"Oooops! We're running out of space on temp.\\n\";\n}\n\nif ($results[$checkTemp] instanceof Result\\FailureInterface) {\n    echo \"It seems that /tmp is not writable - this is a serious problem!\\n\";\n}",
            "title": "Using a result collection"
        },
        {
            "location": "/diagnostics/",
            "text": "Diagnostic Checks\n\n\nzendframework/zenddiagnostics provides several \"just add water\" checks you can\nuse straight away.\n\n\nThe following built-in tests are currently available:\n\n\nApcFragmentation\n\n\nMake sure that \nAPC memory fragmentation level\n is below a\ngiven threshold:\n\n\n<?php\nuse ZendDiagnostics\\Check\\ApcFragmentation;\n\n// Display a warning with fragmentation > 50% and failure when above 90%\n$fragmentation = new ApcFragmentation(50, 90);\n\n\n\nApcMemory\n\n\nCheck \nAPC memory usage percent\n and make sure it's below a\ngiven threshold.\n\n\n<?php\nuse ZendDiagnostics\\Check\\ApcMemory;\n\n// Display a warning with memory usage is above 70% and a failure above 90%\n$checkFreeMemory = new ApcMemory(70, 90);\n\n\n\nCallback\n\n\nRun a function (callback) and use its return value as the result:\n\n\n<?php\nuse ZendDiagnostics\\Check\\Callback;\nuse ZendDiagnostics\\Result\\Success;\nuse ZendDiagnostics\\Result\\Failure;\n\n$checkDbFile = new Callback(function() {\n    $path = __DIR__ . '/data/db.sqlite';\n    if (is_file($path) && is_readable($path) && filesize($path)) {\n        return new Success('Db file is ok');\n    }\n\n        return new Failure('There is something wrong with the db file');\n});\n\n\n\n\n\nCallback signature\n\n\nThe callback must return either a \nboolean\n (true for success, false for\nfailure), or a valid instance of\n\nResultInterface\n.\nAll other objects will result in an exception, and scalars (i.e. a string) will\nbe interpreted as warnings.\n\n\n\n\nClassExists\n\n\nCheck if a class (or an array of classes) exists. For example:\n\n\n<?php\nuse ZendDiagnostics\\Check\\ClassExists;\n\n$checkLuaClass = new ClassExists('Lua');\n$checkRbacClasses = new ClassExists([\n    'ZfcRbac\\Module',\n    'ZfcRbac\\Controller\\Plugin\\IsGranted'\n]);\n\n\n\nCpuPerformance\n\n\nBenchmark CPU performance and return failure if it is below the given ratio. The\nbaseline for performance calculation is the speed of an Amazon EC2 Micro Instance\n(Q1 2013). You can specify the expected performance for the test, where a ratio\nof \n1.0\n (one) means at least the speed of EC2 Micro Instance. A ratio of \n2\n\nwould mean \"at least double the performance of EC2 Micro Instance\" and a\nfraction of \n0.5\n means \"at least half the performance of Micro Instance\".\n\n\nThe following check will test if current server has at least half the CPU power\nof EC2 Micro Instance:\n\n\n<?php\nuse ZendDiagnostics\\Check\\CpuPerformance;\n\n$checkMinCPUSpeed = new CpuPerformance(0.5); // at least 50% of EC2 micro instance\n\n\n\nDirReadable\n\n\nCheck if a given path (or array of paths) points to a directory and it is\nreadable.\n\n\n<?php\nuse ZendDiagnostics\\Check\\DirReadable;\n\n$checkPublic = new DirReadable('public/');\n$checkAssets = new DirReadable([\n    __DIR__ . '/assets/img',\n    __DIR__ . '/assets/js',\n]);\n\n\n\nDirWritable\n\n\nCheck if a given path (or array of paths) points to a directory and if it can be\nwritten to.\n\n\n<?php\nuse ZendDiagnostics\\Check\\DirWritable;\n\n$checkTemporary = new DirWritable('/tmp');\n$checkAssets    = new DirWritable([\n    __DIR__ . '/assets/customImages',\n    __DIR__ . '/assets/customJs',\n    __DIR__ . '/assets/uploads',\n]);\n\n\n\nDiskFree\n\n\nCheck if there is enough remaining free disk space.\n\n\nThe first parameter is the minimum disk space, which can be supplied as an\ninteger (in bytes, e.g. \n1024\n) or as a string with a multiplier (IEC, SI or\nJedec; e.g.  \n\"150MB\"\n). The second parameter is the path to check; on *NIX\nsystems it is an ordinary path (e.g. \n/home\n), while on Windows systems it is a\ndrive letter (e.g.  \n\"C:\"\n).\n\n\n<?php\nuse ZendDiagnostics\\Check\\DiskFree;\n\n$tempHasAtLeast100Megs  = new DiskFree('100MB', '/tmp');\n$homeHasAtLeast1TB      = new DiskFree('1TiB',  '/home');\n$dataHasAtLeast900Bytes = new DiskFree(900, __DIR__ . '/data/');\n\n\n\nExtensionLoaded\n\n\nCheck if a PHP extension (or an array of extensions) is currently loaded.\n\n\n<?php\nuse ZendDiagnostics\\Check\\ExtensionLoaded;\n\n$checkMbstring    = new ExtensionLoaded('mbstring');\n$checkCompression = new ExtensionLoaded([\n    'rar',\n    'bzip2',\n    'zip',\n]);\n\n\n\nHttpService\n\n\nAttempt connection to a given HTTP host or IP address and try to load a web\npage. The check also supports checking response codes and page contents.\n\n\n<?php\nuse ZendDiagnostics\\Check\\HttpService;\n\n// Try to connect to google.com\n$checkGoogle = new HttpService('www.google.com');\n\n// Check port 8080 on localhost\n$checkLocal = new HttpService('127.0.0.1', 8080);\n\n// Check that the page exists (response code must equal 200)\n$checkPage = new HttpService('www.example.com', 80, '/some/page.html', 200);\n\n// Check page content\n$checkPageContent = new HttpService(\n    'www.example.com',\n    80,\n    '/some/page.html',\n    200,\n    '<title>Hello World</title>'\n);\n\n\n\nGuzzleHttpService\n\n\nAttempt connection to a given HTTP host or IP address and try to load a web page\nusing \nGuzzle\n. The check also supports checking\nresponse codes and page contents.\n\n\nThe constructor signature of the \nGuzzleHttpService\n is as follows:\n\n\n/**\n * @param string|Psr\\Http\\Message\\RequestInterface|GuzzleHttp\\Message\\RequestInterface $requestOrUrl\n *     The absolute url to check, or a fully-formed request instance.\n * @param array $headers An array of headers used to create the request\n * @param array $options An array of guzzle options to use when sending the request\n * @param int $statusCode The response status code to check\n * @param null $content The response content to check\n * @param null|GuzzleHttp\\ClientInterface $guzzle Instance of guzzle to use\n * @param string $method The method of the request\n * @param mixed $body The body of the request (used for POST, PUT and DELETE requests)\n * @throws InvalidArgumentException\n */\npublic function __construct(\n    $requestOrUrl,\n    array $headers = [],\n    array $options = [],\n    $statusCode = 200,\n    $content = null,\n    $guzzle = null,\n    $method = 'GET',\n    $body = null\n)\n\n\n\nExamples:\n\n\n<?php\nuse ZendDiagnostics\\Check\\GuzzleHttpService;\n\n// Try to connect to google.com\n$checkGoogle = new GuzzleHttpService('www.google.com');\n\n// Check port 8080 on localhost\n$checkLocal = new GuzzleHttpService('127.0.0.1:8080');\n\n// Check that the page exists (response code must equal 200)\n$checkPage = new GuzzleHttpService('www.example.com/some/page.html');\n\n// Check page content\n$checkPageContent = new GuzzleHttpService(\n    'www.example.com/some/page.html',\n    [],\n    [],\n    200,\n    '<title>Hello World</title>'\n);\n\n// Check that the post request returns the content\n$checkPageContent = new GuzzleHttpService(\n    'www.example.com/user/update',\n    [],\n    [],\n    200,\n    '{\"status\":\"success\"}',\n    'POST',\n    ['post_field' => 'post_value']\n);\n\n\n\nYou can send JSON data by either providing a \nContent-Type\n header that includes\na JSON content type, or creating a request instance with JSON content:\n\n\n// Send page content\n$checkPageContent = new GuzzleHttpService(\n    'api.example.com/ping',\n    ['Content-Type' => 'application/json'],\n    [],\n    200,\n    null,\n    null,\n    'POST',\n    ['ping' => microtime()]\n);\n\n// Assuming Guzzle 6:\nuse GuzzleHttp\\Psr7\\Request;\n$request = new Request(\n    'POST',\n    'http://api.example.com/ping',\n    ['Content-Type' => 'application/json'],\n    json_encode(['ping' => microtime()])\n);\n$checkPageContent = new GuzzleHttpService($request);\n\n\n\nMemcache\n\n\nAttempt to connect to given Memcache server.\n\n\n<?php\nuse ZendDiagnostics\\Check\\Memcache;\n\n$checkLocal  = new Memcache('127.0.0.1'); // default port\n$checkBackup = new Memcache('10.0.30.40', 11212);\n\n\n\nMemcached\n\n\nAttempt to connect to the given Memcached server.\n\n\n<?php\nuse ZendDiagnostics\\Check\\Memcached;\n\n$checkLocal  = new Memcached('127.0.0.1'); // default port\n$checkBackup = new Memcached('10.0.30.40', 11212);\n\n\n\nMongoDb\n\n\nCheck if connection to MongoDb is possible\n\n\n<?php\nuse ZendDiagnostics\\Check\\Mongo;\n\n$mongoCheck = new Mongo('mongodb://127.0.0.1:27017');\n// and with user/password\n$mongoCheck = new Mongo('mongodb://user:password@127.0.0.1:27017');\n\n\n\nMongoDb\n\n\nCheck if a connection to a given MongoDb server is possible.\n\n\n<?php\nuse ZendDiagnostics\\Check\\Mongo;\n\n$mongoCheck = new Mongo('mongodb://127.0.0.1:27017');\n// and with user/password\n$mongoCheck = new Mongo('mongodb://user:password@127.0.0.1:27017');\n\n\n\nPhpVersion\n\n\nCheck if the current PHP version matches the given requirement. The test accepts\n2 parameters: baseline version and optional\n\ncomparison operator\n.\n\n\n<?php\nuse ZendDiagnostics\\Check\\PhpVersion;\n\n$require545orNewer  = new PhpVersion('5.4.5');\n$rejectBetaVersions = new PhpVersion('5.5.0', '<');\n\n\n\nPhpFlag\n\n\nMake sure that the provided PHP flag(s) is enabled or disabled (as defined in\n\nphp.ini\n). You can use this test to alert the user about unsafe or\nbehavior-changing PHP settings.\n\n\n<?php\nuse ZendDiagnostics\\Check\\PhpFlag;\n\n// This check will fail if use_only_cookies is not enabled\n$sessionOnlyUsesCookies = new PhpFlag('session.use_only_cookies', true);\n\n// This check will fail if safe_mode has been enabled\n$noSafeMode = new PhpFlag('safe_mode', false);\n\n// The following will fail if any of the flags is enabled\n$check = new PhpFlag([\n    'expose_php',\n    'ignore_user_abort',\n    'html_errors',\n], false);\n\n\n\nProcessRunning\n\n\nCheck if a given unix process is running. This check supports PIDs and process\nnames.\n\n\n<?php\nuse ZendDiagnostics\\Check\\ProcessRunning;\n\n$checkApache = new ProcessRunning('httpd');\n$checkProcess1000 = new ProcessRunning(1000);\n\n\n\nRabbitMQ\n\n\nValidate that a RabbitMQ service is running.\n\n\n<?php\nuse ZendDiagnostics\\Check\\RabbitMQ;\n\n$rabbitMQCheck = new RabbitMQ('localhost', 5672, 'guest', 'guest', '/');\n\n\n\nRedis\n\n\nValidate that a Redis service is running.\n\n\n<?php\nuse ZendDiagnostics\\Check\\Redis;\n\n$redisCheck = new Redis('localhost', 6379, 'secret');\n\n\n\nSecurityAdvisory\n\n\nRun a security check of libraries locally installed by\n\nComposer\n against \nSensioLabs Security Advisory\ndatabase\n, and warn about potential\nsecurity vulnerabilities.\n\n\n<?php\nuse ZendDiagnostics\\Check\\SecurityAdvisory;\n\n// Warn about any packages that might have security vulnerabilities\n// and require updating\n$security = new SecurityAdvisory();\n\n// Check another composer.lock\n$security = new SecurityAdvisory('/var/www/project/composer.lock');\n\n\n\nStreamWrapperExists\n\n\nCheck if a given stream wrapper (or an array of wrappers) is available. For\nexample:\n\n\n<?php\nuse ZendDiagnostics\\Check\\StreamWrapperExists;\n\n$checkOGGStream   = new StreamWrapperExists('ogg');\n$checkCompression = new StreamWrapperExists([\n    'zlib',\n    'bzip2',\n    'zip',\n]);\n\n\n\nDoctrineMigration\n\n\nMake sure all migrations are applied:\n\n\n<?php\nuse Doctrine\\Migrations\\Configuration\\Configuration;\nuse Doctrine\\ORM\\EntityManager;\nuse ZendDiagnostics\\Check\\DoctrineMigration;\n\n$em = EntityManager::create(/* config */);\n$migrationConfig = new Configuration($em);\n$check = new DoctrineMigration($migrationConfig);",
            "title": "Diagnostic Checks"
        },
        {
            "location": "/diagnostics/#diagnostic-checks",
            "text": "zendframework/zenddiagnostics provides several \"just add water\" checks you can\nuse straight away.  The following built-in tests are currently available:",
            "title": "Diagnostic Checks"
        },
        {
            "location": "/diagnostics/#apcfragmentation",
            "text": "Make sure that  APC memory fragmentation level  is below a\ngiven threshold:  <?php\nuse ZendDiagnostics\\Check\\ApcFragmentation;\n\n// Display a warning with fragmentation > 50% and failure when above 90%\n$fragmentation = new ApcFragmentation(50, 90);",
            "title": "ApcFragmentation"
        },
        {
            "location": "/diagnostics/#apcmemory",
            "text": "Check  APC memory usage percent  and make sure it's below a\ngiven threshold.  <?php\nuse ZendDiagnostics\\Check\\ApcMemory;\n\n// Display a warning with memory usage is above 70% and a failure above 90%\n$checkFreeMemory = new ApcMemory(70, 90);",
            "title": "ApcMemory"
        },
        {
            "location": "/diagnostics/#callback",
            "text": "Run a function (callback) and use its return value as the result:  <?php\nuse ZendDiagnostics\\Check\\Callback;\nuse ZendDiagnostics\\Result\\Success;\nuse ZendDiagnostics\\Result\\Failure;\n\n$checkDbFile = new Callback(function() {\n    $path = __DIR__ . '/data/db.sqlite';\n    if (is_file($path) && is_readable($path) && filesize($path)) {\n        return new Success('Db file is ok');\n    }\n\n        return new Failure('There is something wrong with the db file');\n});",
            "title": "Callback"
        },
        {
            "location": "/diagnostics/#callback-signature",
            "text": "The callback must return either a  boolean  (true for success, false for\nfailure), or a valid instance of ResultInterface .\nAll other objects will result in an exception, and scalars (i.e. a string) will\nbe interpreted as warnings.",
            "title": "Callback signature"
        },
        {
            "location": "/diagnostics/#classexists",
            "text": "Check if a class (or an array of classes) exists. For example:  <?php\nuse ZendDiagnostics\\Check\\ClassExists;\n\n$checkLuaClass = new ClassExists('Lua');\n$checkRbacClasses = new ClassExists([\n    'ZfcRbac\\Module',\n    'ZfcRbac\\Controller\\Plugin\\IsGranted'\n]);",
            "title": "ClassExists"
        },
        {
            "location": "/diagnostics/#cpuperformance",
            "text": "Benchmark CPU performance and return failure if it is below the given ratio. The\nbaseline for performance calculation is the speed of an Amazon EC2 Micro Instance\n(Q1 2013). You can specify the expected performance for the test, where a ratio\nof  1.0  (one) means at least the speed of EC2 Micro Instance. A ratio of  2 \nwould mean \"at least double the performance of EC2 Micro Instance\" and a\nfraction of  0.5  means \"at least half the performance of Micro Instance\".  The following check will test if current server has at least half the CPU power\nof EC2 Micro Instance:  <?php\nuse ZendDiagnostics\\Check\\CpuPerformance;\n\n$checkMinCPUSpeed = new CpuPerformance(0.5); // at least 50% of EC2 micro instance",
            "title": "CpuPerformance"
        },
        {
            "location": "/diagnostics/#dirreadable",
            "text": "Check if a given path (or array of paths) points to a directory and it is\nreadable.  <?php\nuse ZendDiagnostics\\Check\\DirReadable;\n\n$checkPublic = new DirReadable('public/');\n$checkAssets = new DirReadable([\n    __DIR__ . '/assets/img',\n    __DIR__ . '/assets/js',\n]);",
            "title": "DirReadable"
        },
        {
            "location": "/diagnostics/#dirwritable",
            "text": "Check if a given path (or array of paths) points to a directory and if it can be\nwritten to.  <?php\nuse ZendDiagnostics\\Check\\DirWritable;\n\n$checkTemporary = new DirWritable('/tmp');\n$checkAssets    = new DirWritable([\n    __DIR__ . '/assets/customImages',\n    __DIR__ . '/assets/customJs',\n    __DIR__ . '/assets/uploads',\n]);",
            "title": "DirWritable"
        },
        {
            "location": "/diagnostics/#diskfree",
            "text": "Check if there is enough remaining free disk space.  The first parameter is the minimum disk space, which can be supplied as an\ninteger (in bytes, e.g.  1024 ) or as a string with a multiplier (IEC, SI or\nJedec; e.g.   \"150MB\" ). The second parameter is the path to check; on *NIX\nsystems it is an ordinary path (e.g.  /home ), while on Windows systems it is a\ndrive letter (e.g.   \"C:\" ).  <?php\nuse ZendDiagnostics\\Check\\DiskFree;\n\n$tempHasAtLeast100Megs  = new DiskFree('100MB', '/tmp');\n$homeHasAtLeast1TB      = new DiskFree('1TiB',  '/home');\n$dataHasAtLeast900Bytes = new DiskFree(900, __DIR__ . '/data/');",
            "title": "DiskFree"
        },
        {
            "location": "/diagnostics/#extensionloaded",
            "text": "Check if a PHP extension (or an array of extensions) is currently loaded.  <?php\nuse ZendDiagnostics\\Check\\ExtensionLoaded;\n\n$checkMbstring    = new ExtensionLoaded('mbstring');\n$checkCompression = new ExtensionLoaded([\n    'rar',\n    'bzip2',\n    'zip',\n]);",
            "title": "ExtensionLoaded"
        },
        {
            "location": "/diagnostics/#httpservice",
            "text": "Attempt connection to a given HTTP host or IP address and try to load a web\npage. The check also supports checking response codes and page contents.  <?php\nuse ZendDiagnostics\\Check\\HttpService;\n\n// Try to connect to google.com\n$checkGoogle = new HttpService('www.google.com');\n\n// Check port 8080 on localhost\n$checkLocal = new HttpService('127.0.0.1', 8080);\n\n// Check that the page exists (response code must equal 200)\n$checkPage = new HttpService('www.example.com', 80, '/some/page.html', 200);\n\n// Check page content\n$checkPageContent = new HttpService(\n    'www.example.com',\n    80,\n    '/some/page.html',\n    200,\n    '<title>Hello World</title>'\n);",
            "title": "HttpService"
        },
        {
            "location": "/diagnostics/#guzzlehttpservice",
            "text": "Attempt connection to a given HTTP host or IP address and try to load a web page\nusing  Guzzle . The check also supports checking\nresponse codes and page contents.  The constructor signature of the  GuzzleHttpService  is as follows:  /**\n * @param string|Psr\\Http\\Message\\RequestInterface|GuzzleHttp\\Message\\RequestInterface $requestOrUrl\n *     The absolute url to check, or a fully-formed request instance.\n * @param array $headers An array of headers used to create the request\n * @param array $options An array of guzzle options to use when sending the request\n * @param int $statusCode The response status code to check\n * @param null $content The response content to check\n * @param null|GuzzleHttp\\ClientInterface $guzzle Instance of guzzle to use\n * @param string $method The method of the request\n * @param mixed $body The body of the request (used for POST, PUT and DELETE requests)\n * @throws InvalidArgumentException\n */\npublic function __construct(\n    $requestOrUrl,\n    array $headers = [],\n    array $options = [],\n    $statusCode = 200,\n    $content = null,\n    $guzzle = null,\n    $method = 'GET',\n    $body = null\n)  Examples:  <?php\nuse ZendDiagnostics\\Check\\GuzzleHttpService;\n\n// Try to connect to google.com\n$checkGoogle = new GuzzleHttpService('www.google.com');\n\n// Check port 8080 on localhost\n$checkLocal = new GuzzleHttpService('127.0.0.1:8080');\n\n// Check that the page exists (response code must equal 200)\n$checkPage = new GuzzleHttpService('www.example.com/some/page.html');\n\n// Check page content\n$checkPageContent = new GuzzleHttpService(\n    'www.example.com/some/page.html',\n    [],\n    [],\n    200,\n    '<title>Hello World</title>'\n);\n\n// Check that the post request returns the content\n$checkPageContent = new GuzzleHttpService(\n    'www.example.com/user/update',\n    [],\n    [],\n    200,\n    '{\"status\":\"success\"}',\n    'POST',\n    ['post_field' => 'post_value']\n);  You can send JSON data by either providing a  Content-Type  header that includes\na JSON content type, or creating a request instance with JSON content:  // Send page content\n$checkPageContent = new GuzzleHttpService(\n    'api.example.com/ping',\n    ['Content-Type' => 'application/json'],\n    [],\n    200,\n    null,\n    null,\n    'POST',\n    ['ping' => microtime()]\n);\n\n// Assuming Guzzle 6:\nuse GuzzleHttp\\Psr7\\Request;\n$request = new Request(\n    'POST',\n    'http://api.example.com/ping',\n    ['Content-Type' => 'application/json'],\n    json_encode(['ping' => microtime()])\n);\n$checkPageContent = new GuzzleHttpService($request);",
            "title": "GuzzleHttpService"
        },
        {
            "location": "/diagnostics/#memcache",
            "text": "Attempt to connect to given Memcache server.  <?php\nuse ZendDiagnostics\\Check\\Memcache;\n\n$checkLocal  = new Memcache('127.0.0.1'); // default port\n$checkBackup = new Memcache('10.0.30.40', 11212);",
            "title": "Memcache"
        },
        {
            "location": "/diagnostics/#memcached",
            "text": "Attempt to connect to the given Memcached server.  <?php\nuse ZendDiagnostics\\Check\\Memcached;\n\n$checkLocal  = new Memcached('127.0.0.1'); // default port\n$checkBackup = new Memcached('10.0.30.40', 11212);",
            "title": "Memcached"
        },
        {
            "location": "/diagnostics/#mongodb",
            "text": "Check if connection to MongoDb is possible  <?php\nuse ZendDiagnostics\\Check\\Mongo;\n\n$mongoCheck = new Mongo('mongodb://127.0.0.1:27017');\n// and with user/password\n$mongoCheck = new Mongo('mongodb://user:password@127.0.0.1:27017');",
            "title": "MongoDb"
        },
        {
            "location": "/diagnostics/#mongodb_1",
            "text": "Check if a connection to a given MongoDb server is possible.  <?php\nuse ZendDiagnostics\\Check\\Mongo;\n\n$mongoCheck = new Mongo('mongodb://127.0.0.1:27017');\n// and with user/password\n$mongoCheck = new Mongo('mongodb://user:password@127.0.0.1:27017');",
            "title": "MongoDb"
        },
        {
            "location": "/diagnostics/#phpversion",
            "text": "Check if the current PHP version matches the given requirement. The test accepts\n2 parameters: baseline version and optional comparison operator .  <?php\nuse ZendDiagnostics\\Check\\PhpVersion;\n\n$require545orNewer  = new PhpVersion('5.4.5');\n$rejectBetaVersions = new PhpVersion('5.5.0', '<');",
            "title": "PhpVersion"
        },
        {
            "location": "/diagnostics/#phpflag",
            "text": "Make sure that the provided PHP flag(s) is enabled or disabled (as defined in php.ini ). You can use this test to alert the user about unsafe or\nbehavior-changing PHP settings.  <?php\nuse ZendDiagnostics\\Check\\PhpFlag;\n\n// This check will fail if use_only_cookies is not enabled\n$sessionOnlyUsesCookies = new PhpFlag('session.use_only_cookies', true);\n\n// This check will fail if safe_mode has been enabled\n$noSafeMode = new PhpFlag('safe_mode', false);\n\n// The following will fail if any of the flags is enabled\n$check = new PhpFlag([\n    'expose_php',\n    'ignore_user_abort',\n    'html_errors',\n], false);",
            "title": "PhpFlag"
        },
        {
            "location": "/diagnostics/#processrunning",
            "text": "Check if a given unix process is running. This check supports PIDs and process\nnames.  <?php\nuse ZendDiagnostics\\Check\\ProcessRunning;\n\n$checkApache = new ProcessRunning('httpd');\n$checkProcess1000 = new ProcessRunning(1000);",
            "title": "ProcessRunning"
        },
        {
            "location": "/diagnostics/#rabbitmq",
            "text": "Validate that a RabbitMQ service is running.  <?php\nuse ZendDiagnostics\\Check\\RabbitMQ;\n\n$rabbitMQCheck = new RabbitMQ('localhost', 5672, 'guest', 'guest', '/');",
            "title": "RabbitMQ"
        },
        {
            "location": "/diagnostics/#redis",
            "text": "Validate that a Redis service is running.  <?php\nuse ZendDiagnostics\\Check\\Redis;\n\n$redisCheck = new Redis('localhost', 6379, 'secret');",
            "title": "Redis"
        },
        {
            "location": "/diagnostics/#securityadvisory",
            "text": "Run a security check of libraries locally installed by Composer  against  SensioLabs Security Advisory\ndatabase , and warn about potential\nsecurity vulnerabilities.  <?php\nuse ZendDiagnostics\\Check\\SecurityAdvisory;\n\n// Warn about any packages that might have security vulnerabilities\n// and require updating\n$security = new SecurityAdvisory();\n\n// Check another composer.lock\n$security = new SecurityAdvisory('/var/www/project/composer.lock');",
            "title": "SecurityAdvisory"
        },
        {
            "location": "/diagnostics/#streamwrapperexists",
            "text": "Check if a given stream wrapper (or an array of wrappers) is available. For\nexample:  <?php\nuse ZendDiagnostics\\Check\\StreamWrapperExists;\n\n$checkOGGStream   = new StreamWrapperExists('ogg');\n$checkCompression = new StreamWrapperExists([\n    'zlib',\n    'bzip2',\n    'zip',\n]);",
            "title": "StreamWrapperExists"
        },
        {
            "location": "/diagnostics/#doctrinemigration",
            "text": "Make sure all migrations are applied:  <?php\nuse Doctrine\\Migrations\\Configuration\\Configuration;\nuse Doctrine\\ORM\\EntityManager;\nuse ZendDiagnostics\\Check\\DoctrineMigration;\n\n$em = EntityManager::create(/* config */);\n$migrationConfig = new Configuration($em);\n$check = new DoctrineMigration($migrationConfig);",
            "title": "DoctrineMigration"
        },
        {
            "location": "/file-validation/",
            "text": "File Validation Checks\n\n\nzendframework/zenddiagnostics ships with the following file validation checks.\n\n\nIniFile\n\n\nRead an INI-file from the given path and try to parse it.\n\n\n<?php\nuse ZendDiagnostics\\Check\\IniFile;\n\n$checkIniFile = new IniFile('/my/path/to/file.ini');\n$checkIniFile = new IniFile(['file1.ini', 'file2.ini', '...']);\n\n\n\nJsonFile\n\n\nRead a JSON-file from the given path and try to decode it.\n\n\n<?php\nuse ZendDiagnostics\\Check\\JsonFile;\n\n$checkJsonFile = new JsonFile('/my/path/to/file.json');\n$checkJsonFile = new JsonFile(['file1.json', 'file2.json', '...']);\n\n\n\nXmlFile\n\n\nRead an XML-file from the given path, try to parse it, and attempt to validate\nit agaist its DTD schema if possible.\n\n\n<?php\nuse ZendDiagnostics\\Check\\XmlFile;\n\n$checkXmlFile = new XmlFile('/my/path/to/file.xml');\n$checkXmlFile = new XmlFile(['file1.xml', 'file2.xml', '...']);\n\n\n\nYamlFile\n\n\nRead a YAML-file from the given path and try to parse it.\n\n\n<?php\nuse ZendDiagnostics\\Check\\YamlFile;\n\n$checkYamlFile = new YamlFile('/my/path/to/file.yml');\n$checkYamlFile = new YamlFile(['file1.yml', 'file2.yml', '...']);",
            "title": "File Validation Checks"
        },
        {
            "location": "/file-validation/#file-validation-checks",
            "text": "zendframework/zenddiagnostics ships with the following file validation checks.",
            "title": "File Validation Checks"
        },
        {
            "location": "/file-validation/#inifile",
            "text": "Read an INI-file from the given path and try to parse it.  <?php\nuse ZendDiagnostics\\Check\\IniFile;\n\n$checkIniFile = new IniFile('/my/path/to/file.ini');\n$checkIniFile = new IniFile(['file1.ini', 'file2.ini', '...']);",
            "title": "IniFile"
        },
        {
            "location": "/file-validation/#jsonfile",
            "text": "Read a JSON-file from the given path and try to decode it.  <?php\nuse ZendDiagnostics\\Check\\JsonFile;\n\n$checkJsonFile = new JsonFile('/my/path/to/file.json');\n$checkJsonFile = new JsonFile(['file1.json', 'file2.json', '...']);",
            "title": "JsonFile"
        },
        {
            "location": "/file-validation/#xmlfile",
            "text": "Read an XML-file from the given path, try to parse it, and attempt to validate\nit agaist its DTD schema if possible.  <?php\nuse ZendDiagnostics\\Check\\XmlFile;\n\n$checkXmlFile = new XmlFile('/my/path/to/file.xml');\n$checkXmlFile = new XmlFile(['file1.xml', 'file2.xml', '...']);",
            "title": "XmlFile"
        },
        {
            "location": "/file-validation/#yamlfile",
            "text": "Read a YAML-file from the given path and try to parse it.  <?php\nuse ZendDiagnostics\\Check\\YamlFile;\n\n$checkYamlFile = new YamlFile('/my/path/to/file.yml');\n$checkYamlFile = new YamlFile(['file1.yml', 'file2.yml', '...']);",
            "title": "YamlFile"
        },
        {
            "location": "/architecture/",
            "text": "Architecture\n\n\nA single diagnostic \nCheck\n\nperforms one particular test on the application or environment.\n\n\nIt MUST return a \nResult\n\nwhich implements one of the following result interfaces:\n\n\n\n\nSuccess\n - in case the check ran through without any issue.\n\n\nWarning\n - in case there might be something wrong.\n\n\nFailure\n - when the test failed and an intervention is required.\n\n\n\n\nEach test \nResult\n can additionally return:\n\n\n\n\nresult message\n via \ngetMessage()\n. It can be used to describe the context of the result.\n\n\nresult data\n via \ngetData()\n. This can be used for providing detailed information on the cause of particular\n  result, which might be useful for debugging problems.\n\n\n\n\nOne can define additional \nresult interfaces\n,\nto denote additional severity levels (e.g. critical, alert, notice) or\nappropriate actions (i.e. missing, incomplete). However, it is recommended to\nextend the primary set of success, warning, and failure interfaces for\ncompatibility with other applications and libraries.",
            "title": "Architecture"
        },
        {
            "location": "/architecture/#architecture",
            "text": "A single diagnostic  Check \nperforms one particular test on the application or environment.  It MUST return a  Result \nwhich implements one of the following result interfaces:   Success  - in case the check ran through without any issue.  Warning  - in case there might be something wrong.  Failure  - when the test failed and an intervention is required.   Each test  Result  can additionally return:   result message  via  getMessage() . It can be used to describe the context of the result.  result data  via  getData() . This can be used for providing detailed information on the cause of particular\n  result, which might be useful for debugging problems.   One can define additional  result interfaces ,\nto denote additional severity levels (e.g. critical, alert, notice) or\nappropriate actions (i.e. missing, incomplete). However, it is recommended to\nextend the primary set of success, warning, and failure interfaces for\ncompatibility with other applications and libraries.",
            "title": "Architecture"
        },
        {
            "location": "/custom-checks/",
            "text": "Writing Custom Checks\n\n\nA Check class MUST implement \nCheck\n\nand provide the following methods:\n\n\n<?php\nnamespace ZendDiagnostics\\Check;\n\nuse ZendDiagnostics\\Result\\ResultInterface;\n\ninterface CheckInterface\n{\n    /**\n     * @return ResultInterface\n     */\n    public function check();\n\n    /**\n     * Return a label describing this test instance.\n     *\n     * @return string\n     */\n    public function getLabel();\n}\n\n\n\nThe main \ncheck()\n method is responsible for performing the actual check, and is\nexpected to return a \nResult\n.\nIt is recommended to use the built-in result classes for compatibility with the\ndiagnostics Runner and other checks.\n\n\nBelow is an example class that checks if the PHP default timezone is set to UTC.\n\n\n<?php\nnamespace MyApp\\Diagnostics\\Check;\n\nuse ZendDiagnostics\\Check\\CheckInterface;\nuse ZendDiagnostics\\Result\\Success;\nuse ZendDiagnostics\\Result\\Failure;\n\nclass TimezoneSetToUTC implements CheckInterface\n{\n    public function check()\n    {\n        $tz = date_default_timezone_get();\n\n        if ($tz === 'UTC') {\n            return new Success('Default timezone is UTC');\n        }\n\n        return new Failure('Default timezone is not UTC! It is actually ' . $tz);\n    }\n\n    public function getLabel()\n    {\n        return 'Check if PHP default timezone is set to UTC';\n    }\n}",
            "title": "Custom Checks"
        },
        {
            "location": "/custom-checks/#writing-custom-checks",
            "text": "A Check class MUST implement  Check \nand provide the following methods:  <?php\nnamespace ZendDiagnostics\\Check;\n\nuse ZendDiagnostics\\Result\\ResultInterface;\n\ninterface CheckInterface\n{\n    /**\n     * @return ResultInterface\n     */\n    public function check();\n\n    /**\n     * Return a label describing this test instance.\n     *\n     * @return string\n     */\n    public function getLabel();\n}  The main  check()  method is responsible for performing the actual check, and is\nexpected to return a  Result .\nIt is recommended to use the built-in result classes for compatibility with the\ndiagnostics Runner and other checks.  Below is an example class that checks if the PHP default timezone is set to UTC.  <?php\nnamespace MyApp\\Diagnostics\\Check;\n\nuse ZendDiagnostics\\Check\\CheckInterface;\nuse ZendDiagnostics\\Result\\Success;\nuse ZendDiagnostics\\Result\\Failure;\n\nclass TimezoneSetToUTC implements CheckInterface\n{\n    public function check()\n    {\n        $tz = date_default_timezone_get();\n\n        if ($tz === 'UTC') {\n            return new Success('Default timezone is UTC');\n        }\n\n        return new Failure('Default timezone is not UTC! It is actually ' . $tz);\n    }\n\n    public function getLabel()\n    {\n        return 'Check if PHP default timezone is set to UTC';\n    }\n}",
            "title": "Writing Custom Checks"
        },
        {
            "location": "/custom-reporters/",
            "text": "Writing Custom Reporters\n\n\nA reporter is a class implementing\n  \nReporterInterface\n.\n\n\n<?php\nnamespace ZendDiagnostics\\Runner\\Reporter;\n\nuse ArrayObject;\nuse ZendDiagnostics\\Check\\CheckInterface as Check;\nuse ZendDiagnostics\\Result\\Collection as ResultCollection;\nuse ZendDiagnostics\\Result\\ResultInterface as Result;\n\ninterface ReporterInterface\n{\n    public function onStart(ArrayObject $checks, $runnerConfig);\n    public function onBeforeRun(Check $check);\n    public function onAfterRun(Check $check, Result $result);\n    public function onStop(ResultCollection $results);\n    public function onFinish(ResultCollection $results);\n}\n\n\n\nA Runner invokes the above methods while running diagnostics in the following order:\n\n\n\n\nonStart\n - right after calling \nRunner::run()\n\n\nonBeforeRun\n - before each individual Check.\n\n\nonAfterRun\n - after each individual check has finished running.\n\n\nonFinish\n - after Runner has finished its job.\n\n\nonStop\n - in case Runner has been interrupted:\n\n\nwhen the reporter has returned \nfalse\n from the \nonAfterRun\n method\n\n\nor when the runner is configured with \nsetBreakOnFailure(true)\n and one of\n  the checks fails.\n\n\n\n\n\n\n\n\nSome reporter methods can be used to interrupt the operation of a diagnostics\nrunner:\n\n\n\n\nonBeforeRun(Check $check)\n - in case this method returns \nfalse\n, that\n  particular check will be omitted.\n\n\nonAfterRun(Check $check, Result($result))\n - in case this method returns\n  \nfalse\n, the runner will abort checking.\n\n\n\n\nAll other return values are ignored.\n\n\nzendframework/zenddiagnostics ships with a \nsimple Console reporter\n\nthat can serve as an example of how to write your own reporters.",
            "title": "Custom Reporters"
        },
        {
            "location": "/custom-reporters/#writing-custom-reporters",
            "text": "A reporter is a class implementing\n   ReporterInterface .  <?php\nnamespace ZendDiagnostics\\Runner\\Reporter;\n\nuse ArrayObject;\nuse ZendDiagnostics\\Check\\CheckInterface as Check;\nuse ZendDiagnostics\\Result\\Collection as ResultCollection;\nuse ZendDiagnostics\\Result\\ResultInterface as Result;\n\ninterface ReporterInterface\n{\n    public function onStart(ArrayObject $checks, $runnerConfig);\n    public function onBeforeRun(Check $check);\n    public function onAfterRun(Check $check, Result $result);\n    public function onStop(ResultCollection $results);\n    public function onFinish(ResultCollection $results);\n}  A Runner invokes the above methods while running diagnostics in the following order:   onStart  - right after calling  Runner::run()  onBeforeRun  - before each individual Check.  onAfterRun  - after each individual check has finished running.  onFinish  - after Runner has finished its job.  onStop  - in case Runner has been interrupted:  when the reporter has returned  false  from the  onAfterRun  method  or when the runner is configured with  setBreakOnFailure(true)  and one of\n  the checks fails.     Some reporter methods can be used to interrupt the operation of a diagnostics\nrunner:   onBeforeRun(Check $check)  - in case this method returns  false , that\n  particular check will be omitted.  onAfterRun(Check $check, Result($result))  - in case this method returns\n   false , the runner will abort checking.   All other return values are ignored.  zendframework/zenddiagnostics ships with a  simple Console reporter \nthat can serve as an example of how to write your own reporters.",
            "title": "Writing Custom Reporters"
        }
    ]
}